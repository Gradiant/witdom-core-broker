/**
 * WITDOM Broker API
 * API to use services from the Broker
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package eu.witdom.core.broker.client.api;

import eu.witdom.core.broker.client.ApiClient;
import eu.witdom.core.broker.client.ApiException;
import eu.witdom.core.broker.client.model.Request;
import eu.witdom.core.broker.client.model.Error;
import eu.witdom.core.broker.client.model.Result;
import java.math.BigDecimal;
import org.junit.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import java.util.Objects;

/**
 * API tests for RequestApi
 */
public class RequestApiTest {

    String basePath = "http://localhost:5000/v1";
    private ApiClient client = new ApiClient().setBasePath(basePath);
    private final RequestApi api = new RequestApi(client);


    /**
     * Update a request
     *
     * The forward requests just send the request 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void requestCallbackPOSTTest() throws ApiException {

        ObjectMapper mapper = new ObjectMapper();
        ObjectNode objectNode = mapper.createObjectNode();
        objectNode.put("data", "String");
        Result result = new Result().resultData(objectNode);

        String requestId = "string";

        Result response = api.requestCallbackPOST(result, requestId);

        // TODO: test validations
    }
    
    /**
     * Forwards a request to a service or module in a blocking manner
     *
     * This requests works the same as \&quot;/request/create\&quot;, the main difference is that this one will not answer with a request_id, but with the result of the operations performed by the target service. This means that the connection will be open until the service ends the requested operations and may reach timeout if the operations take to long. The access authorization remains the same, it can be accessed with a valid certificate or a valid token.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void requestCreateBlockerPOSTTest() throws ApiException {

        String user = "string";
        String token = "string";
        Request request = new Request();

        request.setServiceName("string");

        request.setRequestType("string");

        request.setRequestUri("string");

        ObjectMapper mapper = new ObjectMapper();
        ObjectNode objectNode = mapper.createObjectNode();
        objectNode.put("data", "String");
        request.setRequestData(objectNode);

        Result response = api.requestCreateBlockerPOST(request, user, token);

        // TODO: test validations
    }
    
    /**
     * Forwarding a request to a service or module
     *
     * With this request starts the forwarding process; where the broker will locate the target service and will perform the previous steps (like moving the data to the untrusted domain) needed to allow the service to do the requested operations.   The broker will answer with a request_id which should be used to later request the operations result or state.   To access this path a external client must provide a valid user token granted by theIAM. For an internal module/service, it&#39;s fine to provide a valid certificate signed by the witdom CA. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void requestCreatePOSTTest() throws ApiException {
        
        String user = "string";
        String token = "string";
        Request request = new Request();

        request.setServiceName("string");

        request.setRequestType("string");

        request.setRequestUri("string");

        ObjectMapper mapper = new ObjectMapper();
        ObjectNode objectNode = mapper.createObjectNode();
        objectNode.put("data", "String");
        request.setRequestData(objectNode);

        String response = api.requestCreatePOST(request, user, token);

        // TODO: test validations
    }
    
    /**
     * Try to get the result of a previous request if available
     *
     * If the request_id is finished then returns the result if not returns an error. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void requestGetresultGETTest() throws ApiException {

        String user = "string";
        String token = "string";
        String requestId = "string";

        Result response = api.requestGetresultGET(user, token, requestId);

        // TODO: test validations
    }
    
}
