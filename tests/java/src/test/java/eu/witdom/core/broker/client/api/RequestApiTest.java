/**
 * WITDOM Broker API
 * API to use services from the Broker
 *
 * OpenAPI spec version: 1.2.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package eu.witdom.core.broker.client.api;

import eu.witdom.core.broker.client.ApiClient;
import eu.witdom.core.broker.client.ApiException;
import eu.witdom.core.broker.client.model.Request;
import eu.witdom.core.broker.client.model.Error;
import eu.witdom.core.broker.client.model.Result;
import org.junit.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import java.util.Objects;

/**
 * API tests for RequestApi
 */
public class RequestApiTest {

    String basePath = "http://localhost:5000/v1";
    private ApiClient client = new ApiClient().setBasePath(basePath);
    private final RequestApi api = new RequestApi(client);


    /**
     * Update a request
     *
     * The broker expects the service to send the results of the request started by the client here. Once the service ends an asyncronous request started by the broker, it will need to send the  result through this method to allow the broker to forward it to the client application.  This method can only be accesed by internal services, so it&#39;s required to provide a valid  certificate signed by the witdom CA. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void requestCallbackPOSTTest() throws ApiException {

        Result result = new Result();
        
        String requestId = "string";

        try {
            api.requestCallbackPOST(result, requestId);
        } catch (Exception ex) {

        }

        // TODO: test validations
    }
    
    /**
     * Forwards a GET request to a service or module in a blocking manner
     *
     * This requests works the same as /request/create, the main difference  is that this one will not answer with a request_id, but with the result of the operations  performed by the target service. This means that the connection will be open until the  service ends the requested operations and may reach timeout if the operations take to long.  The access authorization remains the same, it can be accessed with a valid certificate or  a valid token. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void requestCreateBlockerGETTest() throws ApiException {
        String serviceId = "google";
        String serviceUri = "some_path";
        String xAuthToken = "string";
        try {
            Result response = api.requestCreateBlockerGET(serviceId, serviceUri, xAuthToken);
        } catch (Exception ex) {

        }

        // TODO: test validations
    }

    /**
     * Forwards a POST request to a service or module in a blocking manner
     *
     * This requests works the same as /request/create, the main difference  is that this one will not answer with a request_id, but with the result of the operations  performed by the target service. This means that the connection will be open until the  service ends the requested operations and may reach timeout if the operations take to long.  The access authorization remains the same, it can be accessed with a valid certificate or  a valid token. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void requestCreateBlockerPOSTTest() throws ApiException {
        String serviceId = "google";
        String serviceUri = "some_path";
        //Request requestData = new Request();
        Object requestData;
        String xAuthToken = "string";
        
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode objectNode = mapper.createObjectNode();
        requestData = objectNode;

        try {
            Result response = api.requestCreateBlockerPOST(serviceId, serviceUri, requestData, xAuthToken);
        } catch(Exception ex) {
            
        }

        // TODO: test validations
    }
    
    /**
     * Forwards a GET request to a service or module
     *
     * With this request starts the forwarding process; where the broker  will locate the target service and will perform the previous steps (like asking the PO to protect and move the data to the untrusted domain) needed to allow the service to do the requested operations.  The broker will answer with a request_id which should be used to later request  the operations result or state.  To access this path a external client must provide a valid user token granted by  the IAM. For an internal module/service, it&#39;s fine to provide a valid certificate  signed by the witdom CA. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void requestCreateGETTest() throws ApiException {
        String serviceId = "google";
        String serviceUri = "some_path";
        String xAuthToken = "string";
        try {
            String response = api.requestCreateGET(serviceId, serviceUri, xAuthToken);
        } catch (Exception ex) {

        }

        // TODO: test validations
    }

    /**
     * Forwards a POST request to a service or module
     *
     * With this request starts the forwarding process; where the broker  will locate the target service and will perform the previous steps (like asking the PO to protect and move the data to the untrusted domain) needed to allow the service to do the requested operations.  The broker will answer with a request_id which should be used to later request  the operations result or state.  To access this path a external client must provide a valid user token granted by  the IAM. For an internal module/service, it&#39;s fine to provide a valid certificate  signed by the witdom CA. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void requestCreatePOSTTest() throws ApiException {
        String serviceId = "google";
        String serviceUri = "some_path";
        //Request requestData = new Request();
        Object requestData = new Object();

        ObjectMapper mapper = new ObjectMapper();
        ObjectNode objectNode = mapper.createObjectNode();
        requestData = objectNode;

        String xAuthToken = "string";

        String response = api.requestCreatePOST(serviceId, serviceUri, requestData, xAuthToken);

        // TODO: test validations
    }
    
    /**
     * Try to get the result of a previous request if available
     *
     * Recovers the result of the request identified by the provided request_id. If the request  still being processed by the service, the broker will send a response with the actual status  of the request; ie, the service which is processing the data in that moment. The client  aplication will need to periodically request this info until if gets the result.  To access this data the client will need to present its credentials; a valid user and token  pair or a certificate signed by the witdom CA. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void requestGetresultGETTest() throws ApiException {
        String requestId = "string";
        String xAuthToken = "string";
        try {
            Result response = api.requestGetresultGET(requestId, xAuthToken);
        } catch (Exception ex) {

        }

        // TODO: test validations
    }
    
}
